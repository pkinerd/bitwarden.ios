# AP-32: Consolidate `handleOfflineDelete` and `handleOfflineSoftDelete`

> **Issue:** #32 from ConsolidatedOutstandingIssues.md
> **Severity:** Low | **Complexity:** Low
> **Status:** Resolved
> **Source:** Review2/00_Main_Review.md, Review2/03_VaultRepository_Review.md

## Problem Statement

The `handleOfflineDelete` and `handleOfflineSoftDelete` methods in `VaultRepository.swift` share approximately 80% of their logic. Both methods:

1. Get the user ID from `stateService`
2. Check if the cipher was created offline (existing pending change with `.create` type)
3. If created offline: clean up locally and delete the pending change record
4. Otherwise: persist locally, encode the cipher as `CipherDetailsResponseModel` JSON, and upsert a `.softDelete` pending change

The only meaningful differences are:
- `handleOfflineDelete` calls `cipherService.deleteCipherWithLocalStorage(id:)` to remove the cipher
- `handleOfflineSoftDelete` calls `cipherService.updateCipherWithLocalStorage(encryptedCipher)` to mark it as soft-deleted
- `handleOfflineDelete` includes an org cipher guard (`guard cipher.organizationId == nil`)
- `handleOfflineDelete` needs to fetch the cipher data first (since `deleteCipher` only receives an ID)

## Current Code

**`handleOfflineDelete` at `VaultRepository.swift:1123-1161`:**
```swift
private func handleOfflineDelete(cipherId: String, originalError: Error) async throws {
    let userId = try await stateService.getActiveAccountId()
    // Check for offline-created cipher
    if let existing = try await pendingCipherChangeDataStore.fetchPendingChange(...),
       existing.changeType == .create {
        try await cipherService.deleteCipherWithLocalStorage(id: cipherId)
        if let recordId = existing.id {
            try await pendingCipherChangeDataStore.deletePendingChange(id: recordId)
        }
        return
    }
    guard let cipher = try await cipherService.fetchCipher(withId: cipherId) else { return }
    guard cipher.organizationId == nil else { throw originalError }
    try await cipherService.deleteCipherWithLocalStorage(id: cipherId)
    let cipherResponseModel = try CipherDetailsResponseModel(cipher: cipher)
    let cipherData = try JSONEncoder().encode(cipherResponseModel)
    try await pendingCipherChangeDataStore.upsertPendingChange(
        cipherId: cipherId, userId: userId, changeType: .softDelete,
        cipherData: cipherData, originalRevisionDate: cipher.revisionDate,
        offlinePasswordChangeCount: 0
    )
}
```

**`handleOfflineSoftDelete` at `VaultRepository.swift:1169-1199`:**
```swift
private func handleOfflineSoftDelete(cipherId: String, encryptedCipher: Cipher) async throws {
    let userId = try await stateService.getActiveAccountId()
    // Check for offline-created cipher (identical to handleOfflineDelete)
    if let existing = try await pendingCipherChangeDataStore.fetchPendingChange(...),
       existing.changeType == .create {
        try await cipherService.deleteCipherWithLocalStorage(id: cipherId)
        if let recordId = existing.id {
            try await pendingCipherChangeDataStore.deletePendingChange(id: recordId)
        }
        return
    }
    try await cipherService.updateCipherWithLocalStorage(encryptedCipher)
    let cipherResponseModel = try CipherDetailsResponseModel(cipher: encryptedCipher)
    let cipherData = try JSONEncoder().encode(cipherResponseModel)
    try await pendingCipherChangeDataStore.upsertPendingChange(
        cipherId: cipherId, userId: userId, changeType: .softDelete,
        cipherData: cipherData, originalRevisionDate: encryptedCipher.revisionDate,
        offlinePasswordChangeCount: 0
    )
}
```

The offline-created cipher cleanup block (lines 1128-1137 and 1174-1183) is identical in both methods.

## Assessment

**This issue is valid.** The two methods share significant duplicated logic, particularly the offline-created cipher cleanup block which is byte-for-byte identical. However, the methods have enough differences in their parameters and non-shared logic to make full consolidation somewhat awkward:

1. **Different parameters:** `handleOfflineDelete` receives `(cipherId, originalError)` while `handleOfflineSoftDelete` receives `(cipherId, encryptedCipher)`.
2. **Different local persistence:** One deletes locally, the other updates locally.
3. **Org cipher guard:** Only `handleOfflineDelete` checks for org ownership (because `softDeleteCipher` already checks `isOrgCipher` in the calling catch block).
4. **Cipher data source:** `handleOfflineDelete` fetches the cipher from local storage, while `handleOfflineSoftDelete` uses the cipher passed as a parameter.

The offline-created cipher cleanup block is the clearest candidate for extraction since it is identical in both methods.

## Options

### Option A: Extract Offline-Created Cleanup Helper (Recommended)
- **Effort:** ~30 minutes, ~15 lines added, ~20 lines removed
- **Description:** Extract the identical offline-created cipher cleanup block into a shared private method:
  ```swift
  /// Returns `true` if the cipher was created offline and cleaned up locally,
  /// meaning no server operation is needed.
  private func cleanUpOfflineCreatedCipherIfNeeded(
      cipherId: String,
      userId: String
  ) async throws -> Bool {
      guard let existing = try await pendingCipherChangeDataStore.fetchPendingChange(
          cipherId: cipherId, userId: userId
      ), existing.changeType == .create else {
          return false
      }
      try await cipherService.deleteCipherWithLocalStorage(id: cipherId)
      if let recordId = existing.id {
          try await pendingCipherChangeDataStore.deletePendingChange(id: recordId)
      }
      return true
  }
  ```
  Both methods would call this helper and return early if it returns `true`.
- **Pros:** Eliminates the most clearly duplicated block; minimal impact on readability; each method's unique logic remains in place; follows the project's guard-and-return pattern
- **Cons:** Adds one more private method to the file

### Option B: Full Consolidation into Single Method
- **Effort:** ~1 hour, ~20 lines added, ~50 lines removed
- **Description:** Merge both methods into a single helper with an enum parameter:
  ```swift
  private func handleOfflineDeleteOrSoftDelete(
      cipherId: String,
      encryptedCipher: Cipher?,
      originalError: Error?
  ) async throws
  ```
- **Pros:** Maximum code reduction (~30 lines net)
- **Cons:** The combined method would need conditional logic for org checks, cipher fetching vs parameter usage, and delete vs update -- making it harder to follow; the method signature becomes unclear with two optional parameters; violates single-responsibility

### Option C: Accept As-Is
- **Rationale:** The duplication is limited to ~10 lines (the offline-created cleanup block). The two methods are short (~40 lines each), readable, and self-contained. The cost of maintaining the duplication is low since changes to the cleanup logic would be obvious to apply in both places.

## Recommendation

**Option A: Extract Offline-Created Cleanup Helper.** This targets the clearly identical code block (the offline-created cipher cleanup) without trying to merge two methods that have legitimately different parameters and behavior. It follows the project's established pattern of small private helpers. If the cleanup logic needs to change, it only needs to be updated in one place.

Option B is not recommended because the full consolidation would produce a less readable method with conditional branches for behavior that is conceptually different (hard delete vs soft delete).

## Dependencies

- Related to Issue #31 (error classification pattern) -- both address code duplication in VaultRepository's offline helpers, but are independent fixes.
